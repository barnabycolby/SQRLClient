package io.barnabycolby.sqrlclient.sqrl;

import android.util.Base64;

import io.barnabycolby.sqrlclient.App;
import io.barnabycolby.sqrlclient.exceptions.CryptographyException;
import io.barnabycolby.sqrlclient.R;

import java.nio.charset.Charset;

import org.abstractj.kalium.crypto.Util;
import static org.abstractj.kalium.NaCl.sodium;

/**
 * Wraps a SQRL Identity to provide helper methods for using the identity.
 */
public class SQRLIdentity {
    /**
     * Gets the SQRL Identity public key.
     *
     * @return The identity key.
     */
    public String getIdentityKey() {
        // Currently this simply returns a hardcoded public key
        return "AKcDCChuFwzyHo2gm14fbuFmi27MIjUmcEXJx4pWdLo";
    }

    /**
     * Signs a message using the private key of the SQRL Identity.
     *
     * @return The signed message.
     * @throws CryptographyException  If an unrecoverable cryptographic error occurs when signing the message.
     */
    public String signUsingIdentityPrivateKey(String message) throws CryptographyException {
        // Currently this uses a hardcoded private key that matches
        // the public key used above
        String privateKey = "A3vucIkohGpHGFx7fzTTBi3BWNzeaL8EW4HeyGB22akApwMIKG4XDPIejaCbXh9u4WaLbswiNSZwRcnHilZ0ug";
        byte[] privateKeyAsByteArray = Base64.decode(privateKey, Base64.URL_SAFE);

        // Sign the message
        byte[] messageAsByteArray = message.getBytes(Charset.forName("UTF-8"));
        byte[] signature = Util.prependZeros(64, messageAsByteArray);
        int[] bufferLen = new int[1];
        int result = sodium().crypto_sign_ed25519(signature, bufferLen, messageAsByteArray, messageAsByteArray.length, privateKeyAsByteArray);

        // Check for errors
        if (result < 0) {
            throw new CryptographyException(App.getApplicationResources().getString(R.string.identity_signature_failed));
        }

        signature = Util.slice(signature, 0, 64);
        return Base64.encodeToString(signature, Base64.NO_PADDING | Base64.NO_WRAP | Base64.URL_SAFE);
    }

    /**
     * Gets the server unlock key.
     *
     * The server unlock key is originally generated by the client and then sent to the server to keep.
     * If the key is ever needed by the client, then the server will be able to send us the key.
     *
     * Currently this method simply returns a hardcoded key, until support for the identity lock protocol has been added.
     *
     * @return The server unlock key.
     */
    public String getServerUnlockKey() {
        return "Q2l-DBP2nVbYvTA96n4e_2wulWTgjF3Y6hBzSJAYGTE";
    }

    /**
     * Gets the verify unlock key.
     *
     * The verify unlock key is originally generated by the client and then sent to the server.
     * The server uses it to verify any identity changes, signed by the unlock request signing key.
     *
     * Currently this method simply returns a hardcoded key, until support for the identity lock protocol has been added.
     *
     * @return The verify unlock key.
     */
    public String getVerifyUnlockKey() {
        return "17jqvZdMX6Ykcg-TNWQQdVnGyH_SGy3pwhiIrCVBdiY";
    }
}
